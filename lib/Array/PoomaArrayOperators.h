#ifndef POOMA_POOMA_POOMAARRAYOPERATORS_H
#define POOMA_POOMA_POOMAARRAYOPERATORS_H

///////////////////////////////////////////////////////////////////////////////
//
// WARNING: THIS FILE WAS GENERATED AUTOMATICALLY!
// YOU SHOULD MODIFY THE INPUT FILES INSTEAD OF CHANGING THIS FILE DIRECTLY!
//
// THE FOLLOWING INPUT FILES WERE USED TO MAKE THIS FILE:
//
// MakeOperators
// PoomaOps.in
// PoomaClass.in
//
///////////////////////////////////////////////////////////////////////////////


#if defined(POOMA_POOMA_POOMAOPERATORTAGS_H)
template<int D, class T, class EngineTag> class Tensor;

template<class OutputEngineTag, int D, class T, class EngineTag>
Tensor<D, T, OutputEngineTag>
symmetrize(const Tensor<D, T, EngineTag> &x);
#endif




template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnReal,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
real(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnReal,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnImag,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
imag(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnImag,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnAbs,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
abs(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnAbs,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnArg,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
arg(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnArg,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnNorm,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
norm(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnNorm,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnConj,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
conj(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnConj,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnPow2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
pow2(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnPow2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnPow3,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
pow3(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnPow3,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnPow4,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
pow4(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnPow4,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnMagnitude,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
magnitude(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnMagnitude,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnTrace,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
trace(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnTrace,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnDet,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
det(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnDet,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnTranspose,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
transpose(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnTranspose,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<class OutputSymmetry,int D1,class T1,class E1>
inline typename MakeReturn<UnaryNode<FnSymmetrize<OutputSymmetry>,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> >::Expression_t
symmetrize(const Array<D1,T1,E1> & l)
{
  typedef UnaryNode<FnSymmetrize<OutputSymmetry>,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPolar,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
polar(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
outerProduct(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dotdot(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnMin,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
min(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnMax,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
max(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLT2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
LT(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
LE(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGT2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
GT(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
GE(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
EQ(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
NE(const Array<D1,T1,E1> & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
dot(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnPolar,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
polar(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
outerProduct(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
dotdot(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnMin,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
min(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<FnMax,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
max(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpLT2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
LT(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpLE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
LE(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpGT2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
GT(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpGE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
GE(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
EQ(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<int D1,class T1,class E1,class T2>
inline typename MakeReturn<BinaryNode<OpNE2,
  typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
  typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
NE(const Array<D1,T1,E1> & l,const T2 & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<Array<D1,T1,E1> >::Leaf_t,
    typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<Array<D1,T1,E1> >::make(l),
    CreateLeaf<T2 >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDot,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dot(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDot,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnPolar,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
polar(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnPolar,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
outerProduct(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnOuterProductAsTinyMatrix,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
outerProductAsTinyMatrix(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnOuterProductAsTinyMatrix,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnDotDot,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
dotdot(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnDotDot,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnMin,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
min(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnMin,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<FnMax,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
max(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<FnMax,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLT2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
LT(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLT2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpLE2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
LE(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpLE2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGT2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
GT(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGT2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpGE2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
GE(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpGE2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpEQ2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
EQ(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpEQ2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}

template<class T1,int D2,class T2,class E2>
inline typename MakeReturn<BinaryNode<OpNE2,
  typename CreateLeaf<T1 >::Leaf_t,
  typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> >::Expression_t
NE(const T1 & l,const Array<D2,T2,E2> & r)
{
  typedef BinaryNode<OpNE2,
    typename CreateLeaf<T1 >::Leaf_t,
    typename CreateLeaf<Array<D2,T2,E2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
    CreateLeaf<T1 >::make(l),
    CreateLeaf<Array<D2,T2,E2> >::make(r)));
}
#ifdef PETE_ALLOW_SCALAR_SHIFT
#endif // PETE_ALLOW_SCALAR_SHIFT

#endif // POOMA_POOMA_POOMAARRAYOPERATORS_H

